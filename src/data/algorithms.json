{
  "GENERAL": {
    "avl": {
      "title": "AVL Tree (Adelson–Velsky–Landis)",
      "description": "A self-balancing Binary Search Tree where for every node, the difference in height between its left and right subtrees is at most 1. Unbalances are fixed using rotations.",
      "algorithm": "# Idea:\nIt’s a **Binary Search Tree (BST)** that keeps itself balanced.\n\nFor every single node:\n  - The difference in **height** between its left and right subtrees must be **≤ 1**.\n\nIf an insert or delete makes it unbalanced, we fix it using **rotations**.\n\n## AVL Insertion Steps:\n1. Insert the new key just like in a normal **BST**.\n2. Walk back up the tree from the new node.\n3. For each node, update its height.\n4. Calculate its **balance factor** (left height - right height).\n5. If the factor is > 1 or < -1, the tree is **unbalanced**.\n6. Perform the correct **rotation** to fix it.\n\n## Four Rotation Cases:\n- **LL Case** (Left-Left): A new node was added to the left subtree of the left child. → Fix with a single **Right Rotate**.\n- **RR Case** (Right-Right): A new node was added to the right subtree of the right child. → Fix with a single **Left Rotate**.\n- **LR Case** (Left-Right): A new node was added to the right subtree of the left child. → Fix with a **Left Rotate** on the child, then a **Right Rotate** on the parent.\n- **RL Case** (Right-Left): A new node was added to the left subtree of the right child. → Fix with a **Right Rotate** on the child, then a **Left Rotate** on the parent.",
      "cpp": "AVLNode* insertRec(AVLNode* node, int key) {\n    // 1. Standard BST insertion\n    if (!node) {\n        return new AVLNode(key);\n    }\n    if (key < node->val) {\n        node->left = insertRec(node->left, key);\n    } else if (key > node->val) {\n        node->right = insertRec(node->right, key);\n    } else {\n        return node; // Duplicates ignored\n    }\n\n    // 2. Update height and get balance factor\n    node->height = 1 + max(height(node->left), height(node->right));\n    int balance = getBalance(node);\n\n    // 3. Perform rotations if needed\n    // Left Left Case\n    if (balance > 1 && key < node->left->val) {\n        return rightRotate(node);\n    }\n    // Right Right Case\n    if (balance < -1 && key > node->right->val) {\n        return leftRotate(node);\n    }\n    // Left Right Case\n    if (balance > 1 && key > node->left->val) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n    // Right Left Case\n    if (balance < -1 && key < node->right->val) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    return node;\n}",
      "java": "private AVLNode insertRec(AVLNode node, int key) {\n    // 1. Standard BST insertion\n    if (node == null) {\n        return new AVLNode(key);\n    }\n    if (key < node.val) {\n        node.left = insertRec(node.left, key);\n    } else if (key > node.val) {\n        node.right = insertRec(node.right, key);\n    } else {\n        return node; // Duplicates ignored\n    }\n\n    // 2. Update height and get balance factor\n    node.height = 1 + Math.max(height(node.left), height(node.right));\n    int balance = getBalance(node);\n\n    // 3. Perform rotations if needed\n    // Left Left Case\n    if (balance > 1 && key < node.left.val) {\n        return rightRotate(node);\n    }\n    // Right Right Case\n    if (balance < -1 && key > node.right.val) {\n        return leftRotate(node);\n    }\n    // Left Right Case\n    if (balance > 1 && key > node.left.val) {\n        node.left = leftRotate(node.left);\n        return rightRotate(node);\n    }\n    // Right Left Case\n    if (balance < -1 && key < node.right.val) {\n        node.right = rightRotate(node.right);\n        return leftRotate(node);\n    }\n\n    return node;\n}"
    },
    "rb": {
      "title": "Red–Black Tree (RB Tree)",
      "description": "A BST that uses node colors (Red or Black) to ensure the path from the root to any leaf is roughly the same length, keeping it balanced.",
      "algorithm": "# Idea:\nIt's another self-balancing **BST**, but it uses **colors** instead of heights.\nEach node is colored either **Red** or **Black**.\n\n## RB Properties (rules):\n1. Every node is either **Red** or **Black**.\n2. The **root** is always **Black**.\n3. No two **Red** nodes can be adjacent (a red node cannot have a red parent or child).\n4. Every path from the root to a leaf must have the same number of **Black** nodes.\n\n## RB Insertion Steps:\n1. Insert the new node like a normal **BST**.\n2. Color the new node **Red**.\n3. If any rules are violated (e.g., a Red parent), perform **fixup** operations.\n\n## Fixup Operations:\n- **Recoloring**: Change the colors of nodes to restore the rules.\n- **Rotations**: Perform left or right rotations to restructure the tree.\n\nThese fixups happen in three main cases depending on the color of the new node's **uncle**.",
      "cpp": "void insertFixup(RBNode* z) {\n    while (z->parent->color == RED) {\n        if (z->parent == z->parent->parent->left) {\n            RBNode* y = z->parent->parent->right; // Uncle\n            \n            // Case 1: Uncle is RED\n            if (y->color == RED) {\n                z->parent->color = BLACK;\n                y->color = BLACK;\n                z->parent->parent->color = RED;\n                z = z->parent->parent;\n            } else {\n                // Case 2: Uncle is BLACK and z is a right child\n                if (z == z->parent->right) {\n                    z = z->parent;\n                    leftRotate(z);\n                }\n                // Case 3: Uncle is BLACK and z is a left child\n                z->parent->color = BLACK;\n                z->parent->parent->color = RED;\n                rightRotate(z->parent->parent);\n            }\n        } else {\n            // Symmetric cases for right child parent\n            // ...\n        }\n    }\n    root->color = BLACK;\n}",
      "java": "private void insertFixup(RBNode z) {\n    while (z.parent.color == Color.RED) {\n        if (z.parent == z.parent.parent.left) {\n            RBNode y = z.parent.parent.right; // Uncle\n            \n            // Case 1: Uncle is RED\n            if (y.color == Color.RED) {\n                z.parent.color = Color.BLACK;\n                y.color = Color.BLACK;\n                z.parent.parent.color = Color.RED;\n                z = z.parent.parent;\n            } else {\n                // Case 2: Uncle is BLACK and z is a right child\n                if (z == z.parent.right) {\n                    z = z.parent;\n                    leftRotate(z);\n                }\n                // Case 3: Uncle is BLACK and z is a left child\n                z.parent.color = Color.BLACK;\n                z.parent.parent.color = Color.RED;\n                rightRotate(z.parent.parent);\n            }\n        } else {\n            // Symmetric cases for right child parent\n            // ...\n        }\n    }\n    root.color = Color.BLACK;\n}"
    }
  },
  "BT": {
    "operations": {
      "title": "Binary Tree Operations",
      "description": "A Binary Tree is a data structure where each node can have at most two children (left and right). Unlike a BST, there are no rules about ordering values.",
      "algorithm": "A **Binary Tree** is a data structure where each node can have at most **2 children**:\n- Left child\n- Right child\n\nUnlike BST or AVL, there are **no rules about ordering** the values.\n\n## Node Structure:\nA node typically contains a **value**, and pointers to a **left** and a **right** child.\n\n## Operations:\n\n1. **Traversals** (visiting all nodes)\n   - **Inorder**: Left → Root → Right\n   - **Preorder**: Root → Left → Right\n   - **Postorder**: Left → Right → Root\n   - **Level Order**: visit nodes level by level\n\n2. **Insert**\n   Usually done by filling the tree **level by level**, from left to right.\n\n3. **Delete**\n   A common method is to find the **deepest** node, replace the target's value with the deepest node's value, and then remove the deepest node.",
      "cpp": "void inorder(BTNode* node) {\n    if (!node) {\n        return;\n    }\n    inorder(node->left);\n    cout << node->val << \" \";\n    inorder(node->right);\n}\n\nvoid insert(int v) {\n    if (!root) {\n        root = new BTNode(v);\n        return;\n    }\n    queue<BTNode*> q;\n    q.push(root);\n    while (!q.empty()) {\n        BTNode* node = q.front(); \n        q.pop();\n        \n        if (!node->left) {\n            node->left = new BTNode(v);\n            return;\n        } else {\n            q.push(node->left);\n        }\n        \n        if (!node->right) {\n            node->right = new BTNode(v);\n            return;\n        } else {\n            q.push(node->right);\n        }\n    }\n}",
      "java": "public void inorder(BTNode node) {\n    if (node == null) {\n        return;\n    }\n    inorder(node.left);\n    System.out.print(node.val + \" \");\n    inorder(node.right);\n}\n\npublic void insert(int v) {\n    if (root == null) {\n        root = new BTNode(v);\n        return;\n    }\n    Queue<BTNode> q = new LinkedList<>();\n    q.add(root);\n    while (!q.isEmpty()) {\n        BTNode n = q.remove();\n        \n        if (n.left == null) {\n            n.left = new BTNode(v);\n            return;\n        } else {\n            q.add(n.left);\n        }\n        \n        if (n.right == null) {\n            n.right = new BTNode(v);\n            return;\n        } else {\n            q.add(n.right);\n        }\n    }\n}"
    }
  },
  "BST": {
    "operations": {
      "title": "Binary Search Tree Operations",
      "description": "A BST follows a specific rule: for any node, all values in its left subtree are smaller, and all values in its right subtree are larger.",
      "algorithm": "## Rule:\n- Values **smaller** than a node go to its **left child**.\n- Values **greater** than a node go to its **right child**.\n\nThis property makes searching very fast.\n\n## Operations:\n\n1. **Insertion**\n   Start at the root.\n   Traverse **left** or **right** based on the new value.\n   Insert the new node when an empty spot is found.\n\n2. **Search**\n   Start at the root.\n   Traverse **left** if the key is smaller, **right** if it's larger.\n   Stop when the key is found or an empty spot is reached.\n\n3. **Deletion**\n   - **Case 1 (leaf node)**: Simply remove it.\n   - **Case 2 (one child)**: Replace the node with its only child.\n   - **Case 3 (two children)**: Find its **inorder successor** (smallest value in the right subtree), copy that value to the node, then delete the successor.",
      "cpp": "BSTNode* insertRec(BSTNode* node, int v) {\n    if (!node) {\n        return new BSTNode(v);\n    }\n    if (v < node->val) {\n        node->left = insertRec(node->left, v);\n    } else if (v > node->val) {\n        node->right = insertRec(node->right, v);\n    }\n    return node;\n}\n\nBSTNode* searchRec(BSTNode* node, int key) {\n    if (!node || node->val == key) {\n        return node;\n    }\n    if (key < node->val) {\n        return searchRec(node->left, key);\n    } else {\n        return searchRec(node->right, key);\n    }\n}",
      "java": "private BSTNode insertRec(BSTNode node, int v) {\n    if (node == null) {\n        return new BSTNode(v);\n    }\n    if (v < node.val) {\n        node.left = insertRec(node.left, v);\n    } else if (v > node.val) {\n        node.right = insertRec(node.right, v);\n    }\n    return node;\n}\n\nprivate BSTNode searchRec(BSTNode node, int key) {\n    if (node == null || node.val == key) {\n        return node;\n    }\n    if (key < node.val) {\n        return searchRec(node.left, key);\n    } else {\n        return searchRec(node.right, key);\n    }\n}"
    }
  },
  "HEAP": {
    "operations": {
      "title": "Heap Operations",
      "description": "A Heap is a complete binary tree, usually stored in an array. In a Max-Heap, parents are always greater than or equal to their children.",
      "algorithm": "A **Heap** is a special **complete binary tree**.\n- **Max-Heap**: Parent is always **>=** its children.\n- **Min-Heap**: Parent is always **<=** its children.\n\nHeaps are usually stored in an **array** for efficiency.\n\n## Operations (for Max-Heap):\n\n1. **Insert**\n   Add the new element to the **end** of the array.\n   Then, '**bubble it up**' by repeatedly swapping it with its parent as long as it's larger.\n\n2. **Delete** (usually the root/max)\n   Replace the **root** with the **last element**.\n   Remove the last element.\n   '**Bubble it down**' by swapping it with its **larger child** until the heap property is restored.\n\n3. **Heapify**\n   Convert an array into a heap in **O(n)** time by calling heapify-down on all non-leaf nodes.",
      "cpp": "void insert(int val) {\n    a.push_back(val);\n    heapifyUp(a.size() - 1);\n}\n\nint extractMax() {\n    if (a.empty()) {\n        throw runtime_error(\"Heap empty\");\n    }\n    int mx = a[0];\n    a[0] = a.back();\n    a.pop_back();\n    if (!a.empty()) {\n        heapifyDown(0, a.size());\n    }\n    return mx;\n}",
      "java": "public void insert(int val) {\n    a.add(val);\n    heapifyUp(a.size() - 1);\n}\n\npublic int extractMax() {\n    if (a.isEmpty()) {\n        throw new NoSuchElementException(\"Heap empty\");\n    }\n    int max = a.get(0);\n    int last = a.remove(a.size() - 1);\n    if (!a.isEmpty()) {\n        a.set(0, last);\n        heapifyDown(0, a.size());\n    }\n    return max;\n}"
    }
  },
  "TRIES": {
    "operations": {
      "title": "Trie (Prefix Tree) Operations",
      "description": "A Trie is a special tree used for storing and retrieving strings efficiently. Each node represents a character, and paths from the root form words.",
      "algorithm": "A **Trie** is a special tree for storing strings.\nEach node represents a **character**, and paths down the tree form **words** and **prefixes**.\n\n## Node Structure:\n- An array of **children** (e.g., 26 for 'a'-'z').\n- A **boolean flag** to mark if a word ends at that node.\n\n## Operations (word length L):\n\n1. **Insert (O(L))**\n   For each character, move to the child node.\n   If the path doesn't exist, create the node.\n   Mark the final node as the end of a word.\n\n2. **Search (O(L))**\n   For each character, move to the child.\n   If a path doesn't exist, the word is not found.\n   At the end, check if the **end-of-word** flag is true.\n\n3. **Prefix Check (O(L))**\n   This is the same as search, but you don't need to check the end-of-word flag.",
      "cpp": "void insert(const string &word) {\n    TrieNode* node = root;\n    for (char c : word) {\n        int i = c - 'a';\n        if (!node->children[i]) {\n            node->children[i] = new TrieNode();\n        }\n        node = node->children[i];\n    }\n    node->endOfWord = true;\n}\n\nbool search(const string &word) {\n    TrieNode* node = root;\n    for (char c : word) {\n        int i = c - 'a';\n        if (!node->children[i]) {\n            return false;\n        }\n        node = node->children[i];\n    }\n    return node->endOfWord;\n}",
      "java": "public void insert(String word) {\n    TrieNode node = root;\n    for (char c : word.toCharArray()) {\n        int i = c - 'a';\n        if (node.children[i] == null) {\n            node.children[i] = new TrieNode();\n        }\n        node = node.children[i];\n    }\n    node.endOfWord = true;\n}\n\npublic boolean search(String word) {\n    TrieNode node = root;\n    for (char c : word.toCharArray()) {\n        int i = c - 'a';\n        if (node.children[i] == null) {\n            return false;\n        }\n        node = node.children[i];\n    }\n    return node.endOfWord;\n}"
    }
  }
}